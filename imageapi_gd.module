<?php // $Id: imageapi_gd.module,v 1.8 2008/04/30 15:35:07 dopry Exp $

/**
 * @file
 * GD2 toolkit functions
 */

/**
 * Implementation of hook_imageapi_toolkit().
 *
 * this hook only gets called to see is a module implements the imageapi hooks...
 */
function imageapi_gd_imageapi_toolkit() {
}


/**
 * Settings form for the toolkit.
 */
function imageapi_gd_settings_form() {
  $form['image_jpeg_quality'] = array(
    '#type' => 'textfield',
    '#title' => t('JPEG quality'),
    '#description' => t('Define the image quality for JPEG manipulations. Ranges from 0 to 100. Higher values mean better image quality, but bigger files.'),
    '#size' => 10,
    '#maxlength' => 3,
    '#default_value' => variable_get('image_jpeg_quality', 75),
    '#field_suffix' => '%',
  );
  return system_settings_form($form);
}

function imageapi_gd_image_open($image) {
  if ($image->res =  _gd_open($image->source, $image->info['extension'])) {
    return $image;
  }
  return false;
}

function imageapi_gd_image_close($image, $destination) {
  return _gd_close($image->res, $destination, $image->info['extension']);
}

function imageapi_gd_image_crop(&$image, $x, $y, $width, $height) {
  $res = _gd_create_tmp($image, $width, $height);

  if (!imagecopyresampled($res, $image->res, 0, 0, $x, $y, $width, $height, $width, $height)) {
    return false;
  }
  // destroy the original image and return the modified image.
  imagedestroy($image->res);
  $image->res = $res;
  $image->info['width'] = $width;
  $image->info['height'] = $height;
  return true;
}

function imageapi_gd_image_resize(&$image, $width, $height) {

  $res = _gd_create_tmp($image, $width, $height);

  if (!imagecopyresampled($res, $image->res, 0, 0, 0, 0, $width, $height, $image->info['width'], $image->info['height'])) {
    return false;
  }
  imagedestroy($image->res);
  // update image object
  $image->res = $res;
  $image->info['width'] = $width;
  $image->info['height'] = $height;
  return true;
}

function imageapi_gd_image_rotate(&$image, $degrees, $bgcolor) {
  $res = imagerotate($image->res, $degrees, $bgcolor);
  imagedestroy($image->res);
  $image->res = $res;
  return true;
} 

function imageapi_gd_image_desaturate(&$image) {
  return imagefilter($image->res, IMG_FILTER_GRAYSCALE);
}

/**
 * GD helper function to create an image resource from a file.
 */
function _gd_open($file, $extension) {
  $extension = str_replace('jpg', 'jpeg', $extension);
  $open_func = 'imageCreateFrom'. $extension;
  if (!function_exists($open_func)) {
    return false;
  }
  
  return $open_func($file);
}

/**
 * GD helper to write an image resource to a destination file.
 */
function _gd_close($res, $destination, $extension) {
  $extension = str_replace('jpg', 'jpeg', $extension);
  $close_func = 'image'. $extension;
  if (!function_exists($close_func)) {
    return false;
  }
  if ($extension == 'jpeg') {
    return $close_func($res, $destination, variable_get('image_jpeg_quality', 75));
  }
  else {
    return $close_func($res, $destination);
  }
}

if (!function_exists('imagerotate')) {
  include_once('imagerotate.inc');
}

if (!function_exists('imagefilter')) {
  include_once('imagefilter.inc');
}


/** 
 * create a true color image preserving transparency from a provided
 * image.
 * @todo: add bgcolor setting to add a default background color.
 */
function _gd_create_tmp($image, $width, $height) { 
  $res = imagecreatetruecolor($width, $height);
  
  if ($image->info['extension'] == 'gif' || $image->info['extension'] == 'jpg') {
    // grab transparent color index from src.
    $transparent = imagecolortransparent($image->res);

    // if indexed transparency, lets preserve it.
    if ($transparent >= 0) {
      // get color(r,g,b) for index;
      $transparent = imagecolorsforindex($image->res, $transparent);
      // allocate to new image and get new index.
      $transparent =  (isset($color['alpha'])) 
        ? imagecolorallocatealpha($res, $color['red'], $color['green'], $color['blue'], $color['alpha'])
        : imagecolorallocate($res, $color['red'], $color['green'], $color['blue']);
 
      $transparent = imagecolorallocate($res,  $transparent['red'], $transparent['green'],  $transparent['blue']);
      // flood with our new transparent color.
      imagefill($res, 0, 0, $transparent);
      // tell the new image which color is transparent.
      imagecolortransparent($res, $transparent);
    }
  }
  elseif ($image->info['extension'] == 'png') {
    imagealphablending($res, false);
    $transparency = imagecolorallocatealpha($res, 0, 0, 0, 127);
    imagefill($res, 0, 0, $transparency);
    imagealphablending($res, true);
    imagesavealpha($res, true);
  }
  return $res;
}
